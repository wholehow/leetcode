package dp;

/* 大意：
 * 给定整数N，判断从1-N可以有多少课不同的BST。
 * */

public class Solution96 {
	
	/* 给定序列1 ... n，从序列中构建BST，我们可以枚举序列中的每个数字i，并且使用该数字作为根。
	 * 当然，子序列1 ...（i-1） 位于根的左侧分支，子序列（i + 1）... n位于根的右侧分支。 
	 * 然后，我们可以递归地从子序列中构造子树。 通过上述方法，我们可以确保我们构建的BST是独一无二的，因为它们具有独特的根源。
	 * 问题是计算唯一BST的数量。为此，我们需要定义两个功能：
	 * G(n)：长度为n的序列的唯一BST的数量。
	 * F(i，n)，1 <= i <= n：唯一BST的数量，其中数字i是BST的根，并且序列的范围从1到n。
	 * 可以看出，G(n)是为了解决问题而需要计算的实际函数。并且G(n)可以从F(i，n)导出，其最终将递归地指代G(n)。
	 * G(n) = F(1, n) + F(2, n) + ... + F(n, n). 
	 * 初始值我们可以有G(0)=1, G(1)=1, G(2)=2, G(3)=5。
	 * 根据对于F的定义我们有F(i, n) = G(i-1) * G(n-i)	1 <= i <= n 
	 * 因此G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0) 
	 * */
	
	public int numTrees(int n) {
	    int[] G = new int[n+1];
	    G[0] = G[1] = 1;
	    for (int i = 2; i <= n; i++) {
	    	for (int j = 1; j <= i; j++) {
	    		G[i] += G[j-1] * G[i-j];
	    	}
	    }
	    return G[n];
	}
}
