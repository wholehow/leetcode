# leetcode
记录leetcode刷题的点滴，实现语言Java，编译器Eclipse
## 小伙伴们自行参阅有关文件夹，有更好的想法欢迎即时提出。
## 等到AC80%题目的时候，会做出相应调整。现在无论自己查询还是做出更改都比较麻烦。
### git get
### 如果在GitHub进行了内容修改，一定要先pull到本地在进行push。
### 分享一个个人认为最好的git入门指南 https://try.github.io/levels/1/challenges/1
## 下一步的目标就是hexo+github搭建个人技术博客。
## 请联系
> 微信 QQ22423866(QQ请不要省略)

> Email zuoquan1993cn@gmail.com

# 写一些关于最新刷题的新的。
## 1. Backtracking，回溯法，又名记忆搜索法，是暴力搜寻法中的一种。
回溯法在字符串匹配——朴素匹配算法和KMP匹配算法的比对中体现的淋漓尽致。

> 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

>> 找到一个可能存在的正确的答案

>> 在尝试了所有可能的分步方法后宣告该问题没有答案

> 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。

## 2. BFS，广度优先遍历，多用于树结构和图结构。
广度优先遍历多使用队列，即每一层的个数都遍历到是当前最高优先级。
## 实现方法
> 1.首先将根节点放入队列中。

> 2.从队列中取出第一个节点，并检验它是否为目标。

>> 如果找到目标，则结束搜寻并回传结果。

>> 否则将它所有尚未检验过的直接子节点加入队列中。

> 3.若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。

> 4.重复步骤2。
## 3. DFS，深度优先遍历，多用于树结构和图结构。
深度优先遍历多使用栈，即从当前结点开始走到它能走到的尽头这条路径上的所有结点都被遍历到具有当前最高优先级。
## 实现方法
> 1.首先将根节点放入队列中。

> 2.从队列中取出第一个节点，并检验它是否为目标。

>> 如果找到目标，则结束搜寻并回传结果。

>> 否则将它某一个尚未检验过的直接子节点加入队列中。

> 3.重复步骤2。

> 4.如果不存在未检测过的直接子节点。

>> 将上一级节点加入队列中。

>> 重复步骤2。

> 5.重复步骤4。

> 6.若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。

很多题目以前写过了，偷个懒直接上传。
